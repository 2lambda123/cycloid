# Cycloid STM32 code

This code was mostly generated by the STM32CubeMX utility; the actual code that
does anything is in Src/main.c.

This code is for the Cycloid HAT board: https://easyeda.com/a1k0n/cycloid

It exposes an I2C device on address 0x75 and is also available via the serial
port; in fact, it will send a heartbeat on the serial port every 10ms, just as
it generates the PWM pulse for the servo and speed controller. This way, a
control loop on the Raspberry Pi can be synchronized with the actual pulses
sent to the car hardware.

## I2C addresses

`i2cdump 1 0x75` will show the "registers" exposed by the I2C slave; the first
three addresses can be written to. The `i2cset` / `i2cget` utilities also work.

| Address | Datatype | Function | Read/write |
|-|-|-|-|
| 0x00 | uint8 | Bits 0 and 1 are the red and green LEDs | R/W |
| 0x01 | int8 | Servo position, (-128..127) | R/W |
| 0x02 | int8 | Speed controller position, (-128..127) | R/W |
| 0x03-0x04 | uint16 little-endian | Cumulative motor encoder ticks | R |
| 0x05-0x06 | uint16 little-endian | Motor period, microseconds per tick or 0 if stopped | R |

There are three "encoder ticks" per motor revolution (it's counting the falling
edge of each of the three motor phase windings).

Cumulative encoder ticks wraps at 65536, naturally; just subtract the previous
reading from the current one to get the number of ticks since last reading.
This can be used to determine distance travelled (divide by 3\*total gear ratio,
multiply by wheel circumference).

Motor period gives you the inverse motor velocity; if the field is nonzero,
divide 1000000 / period to get velocity in ticks/second.

## Serial format

The serial protocol sends a 6-byte packet every 10ms at 115200 baud, 8 data
bits, 1 stop bit, no parity:

| Offset | Value | Description |
|-|-|-|
| 0 | 0xAA | sync marker |
| 1-2 | motor encoder ticks (uint16le) | same as address 0x03-0x04 from I2C registers |
| 3-4 | motor encoder period (uint16le) | same as address 0x05-0x06 from I2C registers |
| 5 | checksum | one's complement of sum of bytes 0..4 |

It accepts 5-byte packets:

| Offset | Value | Description |
|-|-|-|
| 0 | 0x55 | Sync marker |
| 1 | LED flags | same as address 0x00 in I2C registers |
| 2 | servo position (int8) | same as address 0x01 |
| 3 | ESC position (int8) | same as address 0x02 |
| 4 | checksum | one's complement of sum of bytes 0..3 |

If the receiver's checksum doesn't match, it will respond with 0xFE (if it was
not already transmitting a packet; otherwise it will silently ignore the input)
