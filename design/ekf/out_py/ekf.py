#!/usr/bin/env python
import numpy as np
from numpy import sin, cos, tan, exp, sqrt, sign, arctan as atan, abs as Abs
from __builtin__ import min as Min, max as Max

# This file is auto-generated by ekf/codegen.py. DO NOT EDIT.


def Heaviside(x):
    return 1 * (x > 0)


def DiracDelta(x, v=1):
    return x == 0 and v or 0


def initial_state():
    x = np.float32(
        [0.0, 0.0, 0.0, 0.0, 0.0, 3.90000009536743, 2.20000004768372, -0.250000000000000, 1.70000004768372, -1.60000002384186, 0.200000002980232, 4.00000000000000, -35.0000000000000, 125.000000000000, 0.0]
    )
    P = np.diag(
        [1.00000011116208e-6, 0.0100000007078052, 4.00000000000000, 1.00000000000000, 0.160000011324883, 0.0625000000000000, 0.0625000000000000, 0.0625000000000000, 0.0625000000000000, 0.250000000000000, 0.250000000000000, 0.250000000000000, 10000.0000000000, 10000.0000000000, 1.00000000000000]
    )

    return x, P


def predict(x, P, Delta_t, u_M, u_delta):
    (v, delta, y_e, psi_e, kappa, ml_1, ml_2, ml_3, ml_4, srv_a, srv_b, srv_r, srvfb_a, srvfb_b, o_g) = x

    tmp0 = exp(ml_3)
    tmp1 = tmp0*v
    tmp2 = Abs(u_M)
    tmp3 = tmp2*exp(ml_2)
    tmp4 = tmp3*v
    tmp5 = tmp2*exp(ml_1)*Heaviside(u_M)
    tmp6 = exp(ml_4)
    tmp7 = v - 0.2
    tmp8 = Max(0, tmp7)
    tmp9 = tmp6*(Heaviside(tmp8) + 1)
    tmp10 = Heaviside(-Delta_t*(-tmp1 - tmp4 + tmp5 - tmp9) - v)
    tmp11 = -Delta_t*(tmp1 + tmp4 - tmp5 + tmp9)
    tmp12 = Heaviside(tmp11 + v)
    tmp13 = Delta_t*tmp12
    tmp14 = tmp13*(tmp0 + tmp3 + tmp6*DiracDelta(tmp8)*Heaviside(tmp7))
    tmp15 = -delta + srv_a*u_delta + srv_b
    tmp16 = Delta_t*srv_r
    tmp17 = Abs(tmp15)
    tmp18 = Min(tmp16, tmp17)
    tmp19 = sign(tmp15)
    tmp20 = 2*tmp18*DiracDelta(tmp15) + tmp19**2*Heaviside(tmp16 - tmp17)
    tmp21 = sin(psi_e)
    tmp22 = Delta_t*(tmp10/2 + tmp14/2 - 1)
    tmp23 = cos(psi_e)
    tmp24 = Max(tmp11, -v)
    tmp25 = Delta_t*(tmp24/2 + v)
    tmp26 = tmp23*tmp25
    tmp27 = Delta_t**2
    tmp28 = tmp12*tmp21*tmp27/2
    tmp29 = kappa*y_e
    tmp30 = tmp29 - 1
    tmp31 = 1/tmp30
    tmp32 = kappa*tmp31
    tmp33 = delta + tmp23*tmp32
    tmp34 = tmp21*tmp25
    tmp35 = tmp12*tmp27*tmp33/2
    tmp36 = 0.1*v + 1.0e-5

    F = np.eye(15)
    F[0, 0] += -tmp10 - tmp14
    F[0, 5] += tmp13*tmp5
    F[0, 6] += -tmp13*tmp4
    F[0, 7] += -tmp1*tmp13
    F[0, 8] += -tmp13*tmp9
    F[1, 1] += -tmp20
    F[1, 9] += tmp20*u_delta
    F[1, 10] += tmp20
    F[1, 11] += Delta_t*tmp19*Heaviside(-tmp16 + tmp17)
    F[2, 0] += tmp21*tmp22
    F[2, 3] += -tmp26
    F[2, 5] += -tmp28*tmp5
    F[2, 6] += tmp28*tmp4
    F[2, 7] += tmp1*tmp28
    F[2, 8] += tmp28*tmp9
    F[3, 0] += tmp22*tmp33
    F[3, 1] += -tmp25
    F[3, 2] += kappa**2*tmp26/tmp30**2
    F[3, 3] += tmp32*tmp34
    F[3, 4] += tmp26*tmp31*(tmp29*tmp31 - 1)
    F[3, 5] += -tmp35*tmp5
    F[3, 6] += tmp35*tmp4
    F[3, 7] += tmp1*tmp35
    F[3, 8] += tmp35*tmp9
    Q = np.float32([ 16, 4, pow(tmp36, 2), pow(tmp36, 2), pow(tmp36, 2), 0.0100000000000000, 0.000100000000000000, 0.000100000000000000, 0.0100000000000000, 0.000100000000000000, 0.000100000000000000, 0.000100000000000000, 1.00000000000000e-6, 1.00000000000000e-10, 1.00000000000000e-10])
    x[0] += tmp24
    x[1] += tmp18*tmp19
    x[2] += -tmp34
    x[3] += -tmp25*tmp33

    P = np.dot(F, np.dot(P, F.T)) + Delta_t * np.diag(Q)
    return x, P


def update_centerline(x, P, a, b, c, y_c, Rk):
    y_e = x[2]
    psi_e = x[3]
    kappa = x[4]
    tmp0 = a*y_c
    tmp1 = b + 2*tmp0
    tmp2 = tmp1**2 + 1
    tmp3 = 1/sqrt(tmp2)
    tmp4 = a*y_c**2 + b*y_c + c - tmp1*y_c
    tmp5 = 2*tmp2**(-1.5)
    tmp6 = 1/tmp2
    tmp7 = 2*tmp6
    tmp8 = tmp1*tmp4
    tmp9 = 2*a
    tmp10 = tmp2**(-2.5)
    tmp11 = 12.0*tmp1*tmp10

    yk = np.float32(
        [-tmp3*tmp4 - y_e, -psi_e + atan(tmp1), a*tmp5 - kappa])

    Hk = np.float32([
        [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]])
    Mk = np.float32([
        [tmp3*y_c*(tmp7*tmp8 + y_c), tmp8/tmp2**(3/2), -tmp3, tmp3*tmp9*(tmp6*tmp8 + y_c)],
        [tmp7*y_c, tmp6, 0, a*tmp7],
        [-tmp0*tmp11 + tmp5, -tmp10*tmp9*(3.0*b + 6.0*tmp0), 0, -a**2*tmp11]])
    Rk = np.dot(Mk, np.dot(Rk, Mk.T))

    S = np.dot(Hk, np.dot(P, Hk.T)) + Rk
    K = np.dot(P, np.dot(Hk.T, np.linalg.inv(S)))
    x += np.dot(K, yk)
    KHk = np.dot(K, Hk)
    P = np.dot((np.eye(len(x)) - KHk), P)
    return x, P


def update_IMU(x, P, g_z):
    v = x[0]
    delta = x[1]
    o_g = x[14]

    yk = np.float32(
        [delta*v + g_z - o_g])

    Hk = np.float32([
        [-delta, -v, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]])

    Rk = np.diag([
        0.000100000000000000])

    S = np.dot(Hk, np.dot(P, Hk.T)) + Rk
    K = np.dot(P, np.dot(Hk.T, np.linalg.inv(S)))
    x += np.dot(K, yk)
    KHk = np.dot(K, Hk)
    P = np.dot((np.eye(len(x)) - KHk), P)
    return x, P


def update_encoders(x, P, dsdt, fb_delta):
    v = x[0]
    delta = x[1]
    srvfb_a = x[12]
    srvfb_b = x[13]

    yk = np.float32(
        [dsdt - 63.0316606304536*v, -delta*srvfb_a + fb_delta - srvfb_b])

    Hk = np.float32([
        [63.0316606304536, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, srvfb_a, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, delta, 1, 0]])

    Rk = np.diag([
        1, 1])

    S = np.dot(Hk, np.dot(P, Hk.T)) + Rk
    K = np.dot(P, np.dot(Hk.T, np.linalg.inv(S)))
    x += np.dot(K, yk)
    KHk = np.dot(K, Hk)
    P = np.dot((np.eye(len(x)) - KHk), P)
    return x, P


