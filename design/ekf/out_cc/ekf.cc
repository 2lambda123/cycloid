#include <Eigen/Dense>
#include "ekf.h"

// This file is auto-generated by ekf/codegen.py. DO NOT EDIT.

using Eigen::VectorXf;
using Eigen::MatrixXf;

#define Min(x, y) fminf(x, y)
#define Max(x, y) fmaxf(x, y)

static inline float Heaviside(float x) {
  return x < 0 ? 0 : 1;
}

static inline float DiracDelta(float x) {
  return x == 0;
}

EKF::EKF() : x_(14), P_(14, 14) {
  Reset();
}


void EKF::Reset() {
  x_ << 0.0,
        0.0,
        0.0,
        0.0,
        0.0,
        3.00000000000000,
        0.769999980926514,
        -0.699999988079071,
        -1.39999997615814,
        0.200000002980232,
        3.79999995231628,
        -35.0000000000000,
        125.000000000000,
        0.0;
  P_.setIdentity();
  P_.diagonal() << 4.00000000000000,
    0.0100000007078052,
    4.00000000000000,
    1.00000000000000,
    0.160000011324883,
    0.0400000028312206,
    0.0400000028312206,
    0.0400000028312206,
    0.250000000000000,
    0.250000000000000,
    0.250000000000000,
    10000.0000000000,
    10000.0000000000,
    1.00000000000000;
}

void EKF::Predict(float Delta_t, float u_M, float u_delta) {
  float v = x_[0];
  float delta = x_[1];
  float y_e = x_[2];
  float psi_e = x_[3];
  float kappa = x_[4];
  float ml_1 = x_[5];
  float ml_2 = x_[6];
  float ml_3 = x_[7];
  float srv_a = x_[8];
  float srv_b = x_[9];
  float srv_r = x_[10];

  float tmp0 = exp(ml_3);
  float tmp1 = tmp0*v;
  float tmp2 = fabsf(u_M);
  float tmp3 = tmp2*exp(ml_2);
  float tmp4 = tmp3*v;
  float tmp5 = tmp2*exp(ml_1)*Heaviside(u_M);
  float tmp6 = Heaviside(-Delta_t*(-tmp1 - tmp4 + tmp5) - v);
  float tmp7 = -Delta_t*(tmp1 + tmp4 - tmp5);
  float tmp8 = Heaviside(tmp7 + v);
  float tmp9 = Delta_t*tmp8;
  float tmp10 = tmp9*(tmp0 + tmp3);
  float tmp11 = -delta + srv_a*u_delta + srv_b;
  float tmp12 = Delta_t*srv_r;
  float tmp13 = fabsf(tmp11);
  float tmp14 = Min(tmp12, tmp13);
  float tmp15 = (((tmp11) > 0) - ((tmp11) < 0));
  float tmp16 = 2*tmp14*DiracDelta(tmp11) + pow(tmp15, 2)*Heaviside(tmp12 - tmp13);
  float tmp17 = sin(psi_e);
  float tmp18 = Delta_t*((1.0L/2.0L)*tmp10 + (1.0L/2.0L)*tmp6 - 1);
  float tmp19 = cos(psi_e);
  float tmp20 = Max(tmp7, -v);
  float tmp21 = Delta_t*((1.0L/2.0L)*tmp20 + v);
  float tmp22 = tmp19*tmp21;
  float tmp23 = pow(Delta_t, 2);
  float tmp24 = (1.0L/2.0L)*tmp17*tmp23*tmp8;
  float tmp25 = kappa*y_e;
  float tmp26 = tmp25 - 1;
  float tmp27 = 1.0/tmp26;
  float tmp28 = kappa*tmp27;
  float tmp29 = delta + tmp19*tmp28;
  float tmp30 = tmp17*tmp21;
  float tmp31 = (1.0L/2.0L)*tmp23*tmp29*tmp8;

  MatrixXf F(14, 14);
  F.setIdentity();
  F(0, 0) += -tmp10 - tmp6;
  F(0, 5) += tmp5*tmp9;
  F(0, 6) += -tmp4*tmp9;
  F(0, 7) += -tmp1*tmp9;
  F(1, 1) += -tmp16;
  F(1, 8) += tmp16*u_delta;
  F(1, 9) += tmp16;
  F(1, 10) += Delta_t*tmp15*Heaviside(-tmp12 + tmp13);
  F(2, 0) += tmp17*tmp18;
  F(2, 3) += -tmp22;
  F(2, 5) += -tmp24*tmp5;
  F(2, 6) += tmp24*tmp4;
  F(2, 7) += tmp1*tmp24;
  F(3, 0) += tmp18*tmp29;
  F(3, 1) += -tmp21;
  F(3, 2) += pow(kappa, 2)*tmp22/pow(tmp26, 2);
  F(3, 3) += tmp28*tmp30;
  F(3, 4) += tmp22*tmp27*(tmp25*tmp27 - 1);
  F(3, 5) += -tmp31*tmp5;
  F(3, 6) += tmp31*tmp4;
  F(3, 7) += tmp1*tmp31;

  VectorXf Q(14);
  Q << 0.490000000000000, 0.490000000000000, pow(0.1*v + 0.001, 2), pow(0.15*v + 0.001, 2), pow(0.75*v + 0.001, 2), 0.0100000000000000, 0.0100000000000000, 0.0100000000000000, 0, 0, 0, 0, 0, 1.00000000000000e-6;
  x_[0] += tmp20;
  x_[1] += tmp14*tmp15;
  x_[2] += -tmp30;
  x_[3] += -tmp21*tmp29;

  P_ = F * P_ * F.transpose();
  P_.diagonal() += Delta_t * Q;
}

bool EKF::UpdateCenterline(float a, float b, float c, float y_c, Eigen::MatrixXf Rk) {
  float y_e = x_[2];
  float psi_e = x_[3];
  float kappa = x_[4];
  float tmp0 = pow(y_c, 2);
  float tmp1 = a*tmp0 - c;
  float tmp2 = a*y_c;
  float tmp3 = pow(a, 2);
  float tmp4 = pow(b, 2) + 4*b*tmp2 + 4*tmp0*tmp3 + 1;
  float tmp5 = pow(tmp4, -1.0L/2.0L);
  float tmp6 = b + 2*tmp2;
  float tmp7 = pow(tmp6, 2) + 1;
  float tmp8 = 2*pow(tmp7, -1.5);
  float tmp9 = tmp1*tmp6;
  float tmp10 = tmp9/tmp4;
  float tmp11 = 2*a;
  float tmp12 = 1.0/tmp7;
  float tmp13 = 2*tmp12;
  float tmp14 = pow(tmp7, -2.5);
  float tmp15 = 12.0*tmp14*tmp6;


  VectorXf yk(3);
  yk << tmp1*tmp5 - y_e,
        -psi_e + atan(tmp6),
        a*tmp8 - kappa;

  MatrixXf Hk(3, 14);
  Hk << 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0;
  MatrixXf Mk(3, 4);
  Mk << tmp5*y_c*(-2*tmp10 + y_c), -tmp9/pow(tmp4, 3.0L/2.0L), -tmp5, tmp11*tmp5*(-tmp10 + y_c),
        tmp13*y_c, tmp12, 0, a*tmp13,
        -tmp15*tmp2 + tmp8, -tmp11*tmp14*(3.0*b + 6.0*tmp2), 0, -tmp15*tmp3;
  Rk = Mk * Rk * Mk.transpose();

  Eigen::Matrix3f S = Hk * P_ * Hk.transpose() + Rk;
  MatrixXf K = P_ * Hk.transpose() * S.inverse();

  x_.noalias() += K * yk;
  P_ = (MatrixXf::Identity(14, 14) - K*Hk) * P_;
  return true;
}

bool EKF::UpdateIMU(float g_z) {
  float v = x_[0];
  float delta = x_[1];
  float o_g = x_[13];


  VectorXf yk(1);
  yk << delta*v + g_z - o_g;

  MatrixXf Hk(1, 14);
  Hk << -delta, -v, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1;

  VectorXf Rk(1);
  Rk << 0.0100000000000000;

  Eigen::MatrixXf S = Hk * P_ * Hk.transpose();
  S.diagonal() += Rk;
  MatrixXf K = P_ * Hk.transpose() * S.inverse();

  x_.noalias() += K * yk;
  P_ = (MatrixXf::Identity(14, 14) - K*Hk) * P_;
  return true;
}

bool EKF::UpdateEncoders(float dsdt, float fb_delta) {
  float v = x_[0];
  float delta = x_[1];
  float srvfb_a = x_[11];
  float srvfb_b = x_[12];


  VectorXf yk(2);
  yk << dsdt - 63.0316606304536*v,
        -delta*srvfb_a + fb_delta - srvfb_b;

  MatrixXf Hk(2, 14);
  Hk << 63.0316606304536, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, srvfb_a, 0, 0, 0, 0, 0, 0, 0, 0, 0, delta, 1, 0;

  VectorXf Rk(2);
  Rk << 14400, 49;

  Eigen::Matrix2f S = Hk * P_ * Hk.transpose();
  S.diagonal() += Rk;
  MatrixXf K = P_ * Hk.transpose() * S.inverse();

  x_.noalias() += K * yk;
  P_ = (MatrixXf::Identity(14, 14) - K*Hk) * P_;
  return true;
}

