#!/usr/bin/env python
import numpy as np
from numpy import sin, cos, tan, exp, sqrt, sign, arctan as atan, abs as Abs
from __builtin__ import min as Min, max as Max

# This file is auto-generated by ekf/codegen.py. DO NOT EDIT.


def Heaviside(x):
    return 1 * (x > 0)


def DiracDelta(x):
    return x == 0 and 1 or 0


def initial_state():
    x = np.float32(
        [0.0, 0.0, 0.0, 0.0, 0.0, 3.40000009536743, 2.29999995231628, -0.600000023841858, 0.800000011920929, -2.29999995231628, 0.109999999403954, 3.29999995231628, -25.0000000000000, 121.000000000000, 0.0]
    )
    P = np.diag(
        [1.00000011116208e-6, 0.0100000007078052, 4.00000000000000, 1.00000000000000, 0.160000011324883, 0.0625000000000000, 0.0625000000000000, 0.0625000000000000, 0.0625000000000000, 0.250000000000000, 0.250000000000000, 0.250000000000000, 10000.0000000000, 10000.0000000000, 1.00000000000000]
    )

    return x, P


def predict(x, P, Delta_t, u_M, u_delta):
    (v, delta, y_e, psi_e, kappa, ml_1, ml_2, ml_3, ml_4, srv_a, srv_b, srv_r, srvfb_a, srvfb_b, o_g) = x

    tmp0 = exp(ml_4)
    tmp1 = exp(ml_3)
    tmp2 = tmp1*v
    tmp3 = Abs(u_M)
    tmp4 = tmp3*exp(ml_2)
    tmp5 = tmp4*v
    tmp6 = tmp3*exp(ml_1)*Heaviside(u_M)
    tmp7 = Heaviside(-Delta_t*(-tmp0 - tmp2 - tmp5 + tmp6) - v)
    tmp8 = -Delta_t*(tmp0 + tmp2 + tmp5 - tmp6)
    tmp9 = Heaviside(tmp8 + v)
    tmp10 = Delta_t*tmp9
    tmp11 = tmp10*(tmp1 + tmp4)
    tmp12 = -delta + srv_a*u_delta + srv_b
    tmp13 = Delta_t*srv_r
    tmp14 = Abs(tmp12)
    tmp15 = Min(tmp13, tmp14)
    tmp16 = sign(tmp12)
    tmp17 = 2*tmp15*DiracDelta(tmp12) + tmp16**2*Heaviside(tmp13 - tmp14)
    tmp18 = sin(psi_e)
    tmp19 = Delta_t*(tmp11/2 + tmp7/2 - 1)
    tmp20 = cos(psi_e)
    tmp21 = Max(tmp8, -v)
    tmp22 = Delta_t*(tmp21/2 + v)
    tmp23 = tmp20*tmp22
    tmp24 = Delta_t**2
    tmp25 = tmp18*tmp24*tmp9/2
    tmp26 = kappa*y_e
    tmp27 = tmp26 - 1
    tmp28 = 1/tmp27
    tmp29 = kappa*tmp28
    tmp30 = delta + tmp20*tmp29
    tmp31 = tmp18*tmp22
    tmp32 = tmp24*tmp30*tmp9/2
    tmp33 = 0.1*v + 1.0e-5

    F = np.eye(15)
    F[0, 0] += -tmp11 - tmp7
    F[0, 5] += tmp10*tmp6
    F[0, 6] += -tmp10*tmp5
    F[0, 7] += -tmp10*tmp2
    F[0, 8] += -tmp0*tmp10
    F[1, 1] += -tmp17
    F[1, 9] += tmp17*u_delta
    F[1, 10] += tmp17
    F[1, 11] += Delta_t*tmp16*Heaviside(-tmp13 + tmp14)
    F[2, 0] += tmp18*tmp19
    F[2, 3] += -tmp23
    F[2, 5] += -tmp25*tmp6
    F[2, 6] += tmp25*tmp5
    F[2, 7] += tmp2*tmp25
    F[2, 8] += tmp0*tmp25
    F[3, 0] += tmp19*tmp30
    F[3, 1] += -tmp22
    F[3, 2] += kappa**2*tmp23/tmp27**2
    F[3, 3] += tmp29*tmp31
    F[3, 4] += tmp23*tmp28*(tmp26*tmp28 - 1)
    F[3, 5] += -tmp32*tmp6
    F[3, 6] += tmp32*tmp5
    F[3, 7] += tmp2*tmp32
    F[3, 8] += tmp0*tmp32
    Q = np.float32([ 16, 4, pow(tmp33, 2), pow(tmp33, 2), pow(tmp33, 2), 0.0100000000000000, 0.000100000000000000, 0.000100000000000000, 0.0100000000000000, 0.000100000000000000, 0.000100000000000000, 0.000100000000000000, 1.00000000000000e-6, 1.00000000000000e-10, 1.00000000000000e-10])
    x[0] += tmp21
    x[1] += tmp15*tmp16
    x[2] += -tmp31
    x[3] += -tmp22*tmp30

    P = np.dot(F, np.dot(P, F.T)) + Delta_t * np.diag(Q)
    return x, P


def update_centerline(x, P, a, b, c, y_c, Rk):
    y_e = x[2]
    psi_e = x[3]
    kappa = x[4]
    tmp0 = a*y_c
    tmp1 = b + 2*tmp0
    tmp2 = tmp1**2 + 1
    tmp3 = 1/sqrt(tmp2)
    tmp4 = a*y_c**2 + b*y_c + c - tmp1*y_c
    tmp5 = 2*tmp2**(-1.5)
    tmp6 = 1/tmp2
    tmp7 = 2*tmp6
    tmp8 = tmp1*tmp4
    tmp9 = 2*a
    tmp10 = tmp2**(-2.5)
    tmp11 = 12.0*tmp1*tmp10

    yk = np.float32(
        [-tmp3*tmp4 - y_e, -psi_e + atan(tmp1), a*tmp5 - kappa])

    Hk = np.float32([
        [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]])
    Mk = np.float32([
        [tmp3*y_c*(tmp7*tmp8 + y_c), tmp8/tmp2**(3/2), -tmp3, tmp3*tmp9*(tmp6*tmp8 + y_c)],
        [tmp7*y_c, tmp6, 0, a*tmp7],
        [-tmp0*tmp11 + tmp5, -tmp10*tmp9*(3.0*b + 6.0*tmp0), 0, -a**2*tmp11]])
    Rk = np.dot(Mk, np.dot(Rk, Mk.T))

    S = np.dot(Hk, np.dot(P, Hk.T)) + Rk
    K = np.dot(P, np.dot(Hk.T, np.linalg.inv(S)))
    x += np.dot(K, yk)
    KHk = np.dot(K, Hk)
    P = np.dot((np.eye(len(x)) - KHk), P)
    return x, P


def update_IMU(x, P, g_z):
    v = x[0]
    delta = x[1]
    o_g = x[14]

    yk = np.float32(
        [delta*v + g_z - o_g])

    Hk = np.float32([
        [-delta, -v, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]])

    Rk = np.diag([
        0.000100000000000000])

    S = np.dot(Hk, np.dot(P, Hk.T)) + Rk
    K = np.dot(P, np.dot(Hk.T, np.linalg.inv(S)))
    x += np.dot(K, yk)
    KHk = np.dot(K, Hk)
    P = np.dot((np.eye(len(x)) - KHk), P)
    return x, P


def update_encoders(x, P, dsdt, fb_delta):
    v = x[0]
    delta = x[1]
    srvfb_a = x[12]
    srvfb_b = x[13]

    yk = np.float32(
        [dsdt - 63.0316606304536*v, -delta*srvfb_a + fb_delta - srvfb_b])

    Hk = np.float32([
        [63.0316606304536, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, srvfb_a, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, delta, 1, 0]])

    Rk = np.diag([
        1, 1])

    S = np.dot(Hk, np.dot(P, Hk.T)) + Rk
    K = np.dot(P, np.dot(Hk.T, np.linalg.inv(S)))
    x += np.dot(K, yk)
    KHk = np.dot(K, Hk)
    P = np.dot((np.eye(len(x)) - KHk), P)
    return x, P


