#!/usr/bin/env python
import numpy as np
from numpy import sin, cos, tan, exp, sqrt, sign, arctan as atan, arctan2 as atan2, abs as Abs
from __builtin__ import min as Min, max as Max

# This file is auto-generated by ekf/codegen.py. DO NOT EDIT.


def Heaviside(x):
    return 1 * (x > 0)


def DiracDelta(x, v=1):
    return x == 0 and v or 0


def initial_state():
    x = np.float32(
        [0.0, 0.0, 0.0]
    )
    P = np.diag(
        [0.0100000, 0.0100000, 0.0100000]
    )

    return x, P


def predict(x, P, Delta_t, u_x, u_theta):
    (p_x, p_y, theta) = x

    tmp0 = Delta_t*u_theta
    tmp1 = theta + tmp0/2
    tmp2 = sin(tmp1)
    tmp3 = tmp2*u_x
    tmp4 = cos(tmp1)
    tmp5 = tmp4*u_x
    tmp6 = 0.25*u_theta
    tmp7 = tmp2**2
    tmp8 = 200*u_x
    tmp9 = tmp4**2
    tmp10 = -(tmp6 - tmp8)*sin(2*theta + tmp0)/2

    F = np.eye(3)
    F[0, 2] += -tmp3
    F[1, 2] += tmp5

    Q = np.zeros((3, 3))
    Q[0, 0] = tmp6*tmp7 + tmp8*tmp9
    Q[0, 1] = tmp10
    Q[1, 0] = tmp10
    Q[1, 1] = tmp6*tmp9 + tmp7*tmp8
    Q[2, 2] = 0.0200000000000000
    x[0] += tmp5
    x[1] += tmp3
    x[2] += tmp0

    P = np.dot(F, np.dot(P, F.T)) + Delta_t * Q
    return x, P


def step(x, u, Delta_t):
    (p_x, p_y, theta) = x
    (u_x, u_theta) = u

    tmp0 = Delta_t*u_theta
    tmp1 = theta + tmp0/2
    tmp2 = cos(tmp1)
    tmp3 = tmp2*u_x
    tmp4 = sin(tmp1)
    tmp5 = tmp4*u_x
    tmp6 = Delta_t/2

    F = np.eye(3)
    F[0, 2] += -tmp5
    F[1, 2] += tmp3

    J = np.zeros((3, 2))
    J[0, 0] = tmp2
    J[0, 1] = -tmp5*tmp6
    J[1, 0] = tmp4
    J[1, 1] = tmp3*tmp6
    J[2, 1] = Delta_t
    x[0] += tmp3
    x[1] += tmp5
    x[2] += tmp0
    return x, F, J


def update_lm_bearing(x, P, l_px, l_x, l_y, Rk):
    p_x = x[0]
    p_y = x[1]
    theta = x[2]
    tmp0 = cos(theta)
    tmp1 = l_y - p_y
    tmp2 = tmp0*tmp1
    tmp3 = sin(theta)
    tmp4 = l_x - p_x
    tmp5 = tmp3*tmp4
    tmp6 = tmp0*tmp4 + tmp1*tmp3
    tmp7 = -tmp2 + tmp5
    tmp8 = 1/(tmp6**2 + tmp7**2)
    tmp9 = tmp3*tmp6
    tmp10 = tmp0*tmp7
    tmp11 = tmp8*(tmp0*tmp6 + tmp3*tmp7)

    yk = np.float32(
        [l_px - atan2(tmp2 - tmp5, tmp6)])

    Hk = np.float32([
        [tmp8*(-tmp10 + tmp9), -tmp11, -1]])
    Mk = np.float32([
        [1, tmp8*(tmp10 - tmp9), tmp11]])
    Rk = np.dot(Mk, np.dot(Rk, Mk.T))

    S = np.dot(Hk, np.dot(P, Hk.T)) + Rk

    LL = -np.dot(yk, np.dot(np.linalg.inv(S), yk)) - 0.5 * np.log((2 * np.pi)**3 * np.linalg.det(S))
    K = np.linalg.lstsq(S, np.dot(Hk, P))[0].T
    x += np.dot(K, yk)
    KHk = np.dot(K, Hk)
    P = np.dot((np.eye(len(x)) - KHk), P)
    return x, P, LL


