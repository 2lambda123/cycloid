#!/usr/bin/env python
import numpy as np
from numpy import sin, cos, tan, exp, sqrt, sign, arctan as atan, abs as Abs
from __builtin__ import min as Min, max as Max

# This file is auto-generated by ekf/codegen.py. DO NOT EDIT.


def Heaviside(x):
    return 1 * (x > 0)


def DiracDelta(x, v=1):
    return x == 0 and v or 0


def initial_state():
    x = np.float32(
        [0.0, 0.0, 0.0, 0.0, 0.0, 3.00000000000000, 0.769999980926514, -0.699999988079071, -1.39999997615814, 0.200000002980232, 3.79999995231628, -35.0000000000000, 125.000000000000, 0.0]
    )
    P = np.diag(
        [4.00000000000000, 0.0100000007078052, 4.00000000000000, 1.00000000000000, 0.160000011324883, 0.0400000028312206, 0.0400000028312206, 0.0400000028312206, 0.250000000000000, 0.250000000000000, 0.250000000000000, 10000.0000000000, 10000.0000000000, 1.00000000000000]
    )

    return x, P


def predict(x, P, Delta_t, u_M, u_delta):
    (v, delta, y_e, psi_e, kappa, ml_1, ml_2, ml_3, srv_a, srv_b, srv_r, srvfb_a, srvfb_b, o_g) = x

    tmp0 = exp(ml_3)
    tmp1 = tmp0*v
    tmp2 = Abs(u_M)
    tmp3 = tmp2*exp(ml_2)
    tmp4 = tmp3*v
    tmp5 = tmp2*exp(ml_1)*Heaviside(u_M)
    tmp6 = Heaviside(-Delta_t*(-tmp1 - tmp4 + tmp5) - v)
    tmp7 = -Delta_t*(tmp1 + tmp4 - tmp5)
    tmp8 = Heaviside(tmp7 + v)
    tmp9 = Delta_t*tmp8
    tmp10 = tmp9*(tmp0 + tmp3)
    tmp11 = -delta + srv_a*u_delta + srv_b
    tmp12 = Delta_t*srv_r
    tmp13 = Abs(tmp11)
    tmp14 = Min(tmp12, tmp13)
    tmp15 = sign(tmp11)
    tmp16 = 2*tmp14*DiracDelta(tmp11) + tmp15**2*Heaviside(tmp12 - tmp13)
    tmp17 = sin(psi_e)
    tmp18 = Delta_t*(tmp10/2 + tmp6/2 - 1)
    tmp19 = cos(psi_e)
    tmp20 = Max(tmp7, -v)
    tmp21 = Delta_t*(tmp20/2 + v)
    tmp22 = tmp19*tmp21
    tmp23 = Delta_t**2
    tmp24 = tmp17*tmp23*tmp8/2
    tmp25 = kappa*y_e
    tmp26 = tmp25 - 1
    tmp27 = 1/tmp26
    tmp28 = kappa*tmp27
    tmp29 = delta + tmp19*tmp28
    tmp30 = tmp17*tmp21
    tmp31 = tmp23*tmp29*tmp8/2

    F = np.eye(14)
    F[0, 0] += -tmp10 - tmp6
    F[0, 5] += tmp5*tmp9
    F[0, 6] += -tmp4*tmp9
    F[0, 7] += -tmp1*tmp9
    F[1, 1] += -tmp16
    F[1, 8] += tmp16*u_delta
    F[1, 9] += tmp16
    F[1, 10] += Delta_t*tmp15*Heaviside(-tmp12 + tmp13)
    F[2, 0] += tmp17*tmp18
    F[2, 3] += -tmp22
    F[2, 5] += -tmp24*tmp5
    F[2, 6] += tmp24*tmp4
    F[2, 7] += tmp1*tmp24
    F[3, 0] += tmp18*tmp29
    F[3, 1] += -tmp21
    F[3, 2] += kappa**2*tmp22/tmp26**2
    F[3, 3] += tmp28*tmp30
    F[3, 4] += tmp22*tmp27*(tmp25*tmp27 - 1)
    F[3, 5] += -tmp31*tmp5
    F[3, 6] += tmp31*tmp4
    F[3, 7] += tmp1*tmp31
    Q = np.float32([ 0.490000000000000, 0.490000000000000, pow(0.1*v + 0.001, 2), pow(0.15*v + 0.001, 2), pow(0.75*v + 0.001, 2), 0.0100000000000000, 0.0100000000000000, 0.0100000000000000, 0, 0, 0, 0, 0, 1.00000000000000e-6])
    x[0] += tmp20
    x[1] += tmp14*tmp15
    x[2] += -tmp30
    x[3] += -tmp21*tmp29

    P = np.dot(F, np.dot(P, F.T)) + Delta_t * np.diag(Q)
    return x, P


def step(x, u, Delta_t):
    (v, delta, y_e, psi_e, kappa, ml_1, ml_2, ml_3, srv_a, srv_b, srv_r, srvfb_a, srvfb_b, o_g) = x
    (u_M, u_delta) = u

    tmp0 = exp(ml_3)
    tmp1 = tmp0*v
    tmp2 = exp(ml_2)
    tmp3 = Abs(u_M)
    tmp4 = tmp2*tmp3
    tmp5 = tmp4*v
    tmp6 = Heaviside(u_M)
    tmp7 = exp(ml_1)
    tmp8 = tmp3*tmp7
    tmp9 = tmp6*tmp8
    tmp10 = -Delta_t*(tmp1 + tmp5 - tmp9)
    tmp11 = Max(tmp10, -v)
    tmp12 = -delta + srv_a*u_delta + srv_b
    tmp13 = sign(tmp12)
    tmp14 = Delta_t*srv_r
    tmp15 = Abs(tmp12)
    tmp16 = Min(tmp14, tmp15)
    tmp17 = sin(psi_e)
    tmp18 = Delta_t*(tmp11/2 + v)
    tmp19 = tmp17*tmp18
    tmp20 = cos(psi_e)
    tmp21 = kappa*y_e
    tmp22 = tmp21 - 1
    tmp23 = 1/tmp22
    tmp24 = kappa*tmp23
    tmp25 = delta + tmp20*tmp24
    tmp26 = Heaviside(-Delta_t*(-tmp1 - tmp5 + tmp9) - v)
    tmp27 = Heaviside(tmp10 + v)
    tmp28 = Delta_t*tmp27
    tmp29 = tmp28*(tmp0 + tmp4)
    tmp30 = tmp13**2*Heaviside(tmp14 - tmp15) + 2*tmp16*DiracDelta(tmp12)
    tmp31 = Delta_t*(tmp26/2 + tmp29/2 - 1)
    tmp32 = tmp18*tmp20
    tmp33 = Delta_t**2
    tmp34 = tmp17*tmp27*tmp33/2
    tmp35 = tmp25*tmp27*tmp33/2
    tmp36 = sign(u_M)
    tmp37 = -tmp2*tmp36*v + tmp36*tmp6*tmp7 + tmp8*DiracDelta(u_M)

    F = np.eye(14)
    F[0, 0] += -tmp26 - tmp29
    F[0, 5] += tmp28*tmp9
    F[0, 6] += -tmp28*tmp5
    F[0, 7] += -tmp1*tmp28
    F[1, 1] += -tmp30
    F[1, 8] += tmp30*u_delta
    F[1, 9] += tmp30
    F[1, 10] += Delta_t*tmp13*Heaviside(-tmp14 + tmp15)
    F[2, 0] += tmp17*tmp31
    F[2, 3] += -tmp32
    F[2, 5] += -tmp34*tmp9
    F[2, 6] += tmp34*tmp5
    F[2, 7] += tmp1*tmp34
    F[3, 0] += tmp25*tmp31
    F[3, 1] += -tmp18
    F[3, 2] += kappa**2*tmp32/tmp22**2
    F[3, 3] += tmp19*tmp24
    F[3, 4] += tmp23*tmp32*(tmp21*tmp23 - 1)
    F[3, 5] += -tmp35*tmp9
    F[3, 6] += tmp35*tmp5
    F[3, 7] += tmp1*tmp35

    J = np.zeros((14, 2))
    J[0, 0] = tmp28*tmp37
    J[1, 1] = srv_a*tmp30
    J[2, 0] = -tmp34*tmp37
    J[3, 0] = -tmp35*tmp37
    x[0] += tmp11
    x[1] += tmp13*tmp16
    x[2] += -tmp19
    x[3] += -tmp18*tmp25
    return x, F, J


def update_centerline(x, P, a, b, c, y_c, Rk):
    y_e = x[2]
    psi_e = x[3]
    kappa = x[4]
    tmp0 = y_c**2
    tmp1 = a*tmp0 - c
    tmp2 = a*y_c
    tmp3 = a**2
    tmp4 = b**2 + 4*b*tmp2 + 4*tmp0*tmp3 + 1
    tmp5 = 1/sqrt(tmp4)
    tmp6 = b + 2*tmp2
    tmp7 = tmp6**2 + 1
    tmp8 = 2*tmp7**(-1.5)
    tmp9 = tmp1*tmp6
    tmp10 = tmp9/tmp4
    tmp11 = 2*a
    tmp12 = 1/tmp7
    tmp13 = 2*tmp12
    tmp14 = tmp7**(-2.5)
    tmp15 = 12.0*tmp14*tmp6

    yk = np.float32(
        [tmp1*tmp5 - y_e, -psi_e + atan(tmp6), a*tmp8 - kappa])

    Hk = np.float32([
        [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0]])
    Mk = np.float32([
        [tmp5*y_c*(-2*tmp10 + y_c), -tmp9/tmp4**(3/2), -tmp5, tmp11*tmp5*(-tmp10 + y_c)],
        [tmp13*y_c, tmp12, 0, a*tmp13],
        [-tmp15*tmp2 + tmp8, -tmp11*tmp14*(3.0*b + 6.0*tmp2), 0, -tmp15*tmp3]])
    Rk = np.dot(Mk, np.dot(Rk, Mk.T))

    S = np.dot(Hk, np.dot(P, Hk.T)) + Rk

    LL = -np.dot(yk, np.dot(np.linalg.inv(S), yk)) - 0.5 * np.log(2 * np.pi * np.linalg.det(S))
    K = np.linalg.lstsq(S, np.dot(Hk, P))[0].T
    x += np.dot(K, yk)
    KHk = np.dot(K, Hk)
    P = np.dot((np.eye(len(x)) - KHk), P)
    return x, P, LL


def update_IMU(x, P, g_z):
    v = x[0]
    delta = x[1]
    o_g = x[13]

    yk = np.float32(
        [delta*v + g_z - o_g])

    Hk = np.float32([
        [-delta, -v, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]])

    Rk = np.diag([
        0.0100000000000000])

    S = np.dot(Hk, np.dot(P, Hk.T)) + Rk

    LL = -np.dot(yk, np.dot(np.linalg.inv(S), yk)) - 0.5 * np.log(2 * np.pi * np.linalg.det(S))
    K = np.linalg.lstsq(S, np.dot(Hk, P))[0].T
    x += np.dot(K, yk)
    KHk = np.dot(K, Hk)
    P = np.dot((np.eye(len(x)) - KHk), P)
    return x, P, LL


def update_encoders(x, P, dsdt, fb_delta):
    v = x[0]
    delta = x[1]
    srvfb_a = x[11]
    srvfb_b = x[12]

    yk = np.float32(
        [dsdt - 63.0316606304536*v, -delta*srvfb_a + fb_delta - srvfb_b])

    Hk = np.float32([
        [63.0316606304536, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, srvfb_a, 0, 0, 0, 0, 0, 0, 0, 0, 0, delta, 1, 0]])

    Rk = np.diag([
        14400, 49])

    S = np.dot(Hk, np.dot(P, Hk.T)) + Rk

    LL = -np.dot(yk, np.dot(np.linalg.inv(S), yk)) - 0.5 * np.log(2 * np.pi * np.linalg.det(S))
    K = np.linalg.lstsq(S, np.dot(Hk, P))[0].T
    x += np.dot(K, yk)
    KHk = np.dot(K, Hk)
    P = np.dot((np.eye(len(x)) - KHk), P)
    return x, P, LL


