#include <Eigen/Dense>
#include "ekf.h"

// This file is auto-generated by ekf/codegen.py. DO NOT EDIT.

using Eigen::VectorXf;
using Eigen::MatrixXf;

#define Min(x, y) fminf(x, y)
#define Max(x, y) fmaxf(x, y)

static inline float Heaviside(float x) {
  return x < 0 ? 0 : 1;
}

static inline float DiracDelta(float x) {
  return x == 0;
}

EKF::EKF() : x_(8), P_(8, 8) {
  Reset();
}


void EKF::Reset() {
  x_ << 0.0,
        0.0,
        1.0,
        0.05000000074505806,
        0.029999999329447746,
        1.0,
        0.0,
        1.0;
  P_.setIdentity();
  P_.diagonal() << 1.0,
    1.0,
    1.0,
    0.010000000707805157,
    0.010000000707805157,
    1.0,
    1.0,
    1.0;
}

void EKF::Predict(float Delta_t, float u_M, float u_delta) {
  float v = x_[0];
  float delta = x_[1];
  float k1 = x_[2];
  float k2 = x_[3];
  float k3 = x_[4];
  float srv_a = x_[5];
  float srv_b = x_[6];
  float srv_r = x_[7];

  float tmp0 = fabsf(u_M);
  float tmp1 = k2*tmp0;
  float tmp2 = tmp0*Heaviside(u_M);
  float tmp3 = Delta_t*v;
  float tmp4 = Delta_t*srv_r;
  float tmp5 = -delta + srv_a*u_delta + srv_b;

  MatrixXf F(8, 8);
  F.setIdentity();
  F(0, 0) += -Delta_t*(k3 + tmp1);
  F(0, 2) += Delta_t*tmp2;
  F(0, 3) += -tmp0*tmp3;
  F(0, 4) += -tmp3;
  F(1, 1) += -tmp4;
  F(1, 5) += tmp4*u_delta;
  F(1, 6) += tmp4;
  F(1, 7) += Delta_t*tmp5;

  VectorXf Q(8);
  Q << 0.25, 1.0000000000000002e-10, 9.0000000000000002e-6, 9.9999999999999998e-13, 9.9999999999999998e-13, 0, 0, 0;
  x_[0] += -Delta_t*(-k1*tmp2 + k3*v + tmp1*v);
  x_[1] += tmp4*tmp5;

  P_ = F * P_ * F.transpose();
  P_.diagonal() += Delta_t * Q;
}

bool EKF::UpdateIMU(float g_z) {
  float v = x_[0];
  float delta = x_[1];


  VectorXf yk(1);
  yk << -delta*v + g_z;

  MatrixXf Hk(1, 8);
  Hk << delta, v, 0, 0, 0, 0, 0, 0;

  VectorXf Rk(1);
  Rk << pow(v + 0.001, 2);

  Eigen::MatrixXf S = Hk * P_ * Hk.transpose();
  S.diagonal() += Rk;
  MatrixXf K = P_ * Hk.transpose() * S.inverse();

  x_.noalias() += K * yk;
  P_ = (MatrixXf::Identity(8, 8) - K*Hk) * P_;
  return true;
}

bool EKF::UpdateEncoders(float dsdt, float wperiod) {
  float v = x_[0];
  float tmp0 = -v;


  VectorXf yk(2);
  yk << dsdt + tmp0,
        tmp0 + wperiod;

  MatrixXf Hk(2, 8);
  Hk << 1, 0, 0, 0, 0, 0, 0, 0,
        1, 0, 0, 0, 0, 0, 0, 0;

  VectorXf Rk(2);
  Rk << 13.690000000000001, 12.25;

  Eigen::Matrix2f S = Hk * P_ * Hk.transpose();
  S.diagonal() += Rk;
  MatrixXf K = P_ * Hk.transpose() * S.inverse();

  x_.noalias() += K * yk;
  P_ = (MatrixXf::Identity(8, 8) - K*Hk) * P_;
  return true;
}

